Generate a PROJECT_CONTEXT.md for this repository. Extract facts only — no analysis, no opinions, no scoring.

## Scope Check

Before reading files, determine:
1. Is this a monorepo or single service? (check for workspaces, lerna, nx, turborepo config)
2. What is the primary language? (check for package.json, pyproject.toml, go.mod, Cargo.toml, mix.exs, Gemfile)
3. Estimate repo size: count files and directories at top 2 levels

If this is a monorepo, focus on the primary/largest service unless the user specifies otherwise.
If the repo is under 500 LOC, note this and produce an abbreviated context (skip sampling, dependency deep-dive).

## Extraction Steps

### 1. Root Configuration
Read these files if they exist (skip silently if missing):
- README.md (or README.rst, README.txt)
- package.json / pyproject.toml / go.mod / Cargo.toml / build.gradle
- Lockfile (package-lock.json, yarn.lock, pnpm-lock.yaml, poetry.lock, Cargo.lock, go.sum)
- docker-compose.yml / Dockerfile
- Makefile / justfile / taskfile.yml
- .env.example (NEVER read .env — only .env.example)
- tsconfig.json / .eslintrc / .prettierrc / ruff.toml / setup.cfg

### 2. Directory Structure
Map the project tree to 2 levels deep. Exclude: node_modules, .git, __pycache__, .next, dist, build, .venv, vendor.

### 3. Entry Points
Identify application entry points:
- Web: main server file, route definitions, app initialization
- CLI: bin/ scripts, __main__.py, main.go
- Library: exports, public API surface

### 4. Module Sampling
Select 3 representative modules using this priority:
1. Most-imported/most-referenced file
2. Largest non-generated source file
3. A file demonstrating the core domain logic

For each, note: file path, approximate LOC, purpose, key patterns observed.

### 5. Test Infrastructure
- Test framework (jest, pytest, vitest, go test, etc.)
- Test location (co-located, separate test/ dir, both)
- Coverage configuration (present/absent, threshold if set)
- Approximate test file count
- CI test execution (found in workflows or not)

### 6. Dependency Inventory
From lockfile/manifest, extract:
- Total dependency count (direct + transitive if available)
- Key dependencies (table: name, version, purpose) — limit to 15 most significant
- Oldest dependency version (potential staleness indicator)
- Any known deprecated packages

### 7. CI/CD & Infrastructure
- CI platform (.github/workflows, .gitlab-ci.yml, Jenkinsfile, .circleci)
- Pipeline stages found (lint, test, build, deploy)
- Deployment target indicators (Vercel, AWS, GCP, Heroku, Docker, k8s)
- Infrastructure-as-code (terraform, pulumi, CDK, cloudformation)

### 8. Security Signals
- Authentication mechanism (OAuth, JWT, session, API keys, none observed)
- Secrets management (.env.example present, vault config, AWS SSM references)
- .gitignore covers: .env, credentials, keys, tokens
- HTTPS/TLS indicators
- Dependency audit config (npm audit, safety, snyk, dependabot)
- SECURITY.md or security policy present
- Hardcoded strings that look like secrets (flag but do NOT extract values)

## Output

Write PROJECT_CONTEXT.md to the project root using the template structure from templates/PROJECT_CONTEXT.md (or the inline structure below if templates aren't available).

Keep total output under 3000 tokens. Be precise and factual. If something is ambiguous, say "unclear" rather than guessing.

### Fallback Template Structure

If the template file is not accessible, use this structure:

```markdown
# Project Context: [PROJECT NAME]
> Auto-generated by /scout on [DATE]. Review before running /assess.

## Metadata
- **Name**: 
- **Description**: 
- **License**: 
- **Primary Language**: 
- **Framework(s)**: 
- **Repo Size**: ~X files, ~Y LOC (estimated)
- **Last Commit**: [date if determinable from git log]
- **Monorepo**: yes/no

## Tech Stack
| Layer | Technology | Version |
|-------|-----------|---------|
| Runtime | | |
| Framework | | |
| Database | | |
| Cache | | |
| Auth | | |
| Hosting | | |

## Key Dependencies
| Name | Version | Purpose |
|------|---------|---------|
| | | |

## Directory Structure
[tree output, 2 levels]

## Entry Points
- **Main**: `path/to/entry`
- **Routes/API**: `path/to/routes`

## Module Samples
### [file1.ext] (~X LOC)
Purpose: ...
Patterns: ...

### [file2.ext] (~X LOC)
Purpose: ...
Patterns: ...

### [file3.ext] (~X LOC)
Purpose: ...
Patterns: ...

## Test Infrastructure
- **Framework**: 
- **Location**: 
- **Coverage Config**: yes/no (threshold: X%)
- **Test File Count**: ~X
- **CI Execution**: yes/no

## CI/CD
- **Platform**: 
- **Stages**: 
- **Deploy Target**: 

## Security Signals
- **Auth Mechanism**: 
- **Secrets Management**: 
- **.gitignore Coverage**: adequate / incomplete / missing
- **Dependency Auditing**: 
- **Security Policy**: present / absent
- **Concerns**: [list any red flags]
```

After writing the file, report: "Scout complete. Review PROJECT_CONTEXT.md before running /assess."
